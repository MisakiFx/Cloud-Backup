# 快备
## 开发环境
&emsp;&emsp;本项目开发完全在Centos7.2版本下使用C/Cpp进行开发，gcc版本5.3.1，用到的库有httplib，boost及zlib，工具有gcc,gdb,makefile,git。
## 项目介绍
### 功能介绍
&emsp;&emsp;“快备”可以让Windows用户安全可靠的将文件上传到云端进行备份，并且可以随时下载下来。“快备”通过在用户本地创建一个共享文件夹，只要用户将需要备份的文件放入文件夹内，启动程序快备即可自动完成备份，并且如果共享文件夹中文件有了修改则会再次自动备份文件。在云端，文件会存储在指定目录下，如果一个文件长期未被下载则会被自动标记为低热度文件，“快备”会将其自动打包压缩存储起来以节省空间，如果用户下载此文件则会自动将其解压，恢复为高热度文件。用户想要下载文件只需要打开浏览器访问服务器即可得到文件列表，点击对应文件即可下载。
### 功能模块
#### 客户端
&emsp;&emsp;客户端主要负责文件信息的监控来判断需要备份的文件和将文件传输到服务端，具有以下功能：</br>
&emsp;&emsp;1、文件监控功能。这个功能主要时为了辨别共享文件夹中有哪些文件需要备份。客户端会实时对共享文件夹进行循环监控，监控时会在内存中临时生成一个映射，用于存储文件名及其对应的文件信息，文件信息由最后修改时间和文件大小组成，而每轮监控都会遍历目录获取每个文件的文件信息与存储在内存中的文件信息进行对比，如果内存中没有此文件信息或文件信息不符则说明文件是新增的或者是修改过的需要进行备份。在每轮遍历结束时会将所有文件信息写入一个`.list`文件进行存储，用于下次启动程序时获取相应的文件信息。</br>
&emsp;&emsp;2、文件上传功能。当检测出有文件需要备份时则会组织`HTTP`协议将文件传输到服务器上。传输过程中，考虑到传输的速度我选择利用多线程分块并行对文件进行传输，以提高传输速度。分块传输是利用多线程分别读取文件的不同部分来实现的，同时将分块信息通过`HTTP`协议中的`range`发送给服务端方便服务端进行接收。</br>
#### 服务端
&emsp;&emsp;服务端主要负责文件的接收存储，低热度文件压缩及文件在浏览器显示下载。其具有以下功能：</br>
&emsp;&emsp;1、文件接收功能。当客户端发送`HTTP`请求要求服务端接收文件数据时，由于是分块对文件进行传输，因此服务端也需要对文件分块进行接收，只需要结合客户端发送的`range`信息将数据写入文件即可。</br>
&emsp;&emsp;2、低热度文件压缩存储功能。对文件热度检测需要对文件进行监控，为了文件接收下载与文件监控两不误我采用多线程的方式对文件进行监控。监控中遍历存储文件的文件夹，获取文件夹中每个文件的最后修改时间用于判断是否是地热度文件，如果是低热度文件则需要进行压缩存储。文件压缩存储在另一个文件夹中，为了能够通过原文件找到压缩后的文件于是建立映射，并将映射存储在一个`.list`文件中。映射的添加在接收文件成功后就会添加映射，而非压缩文件后才会添加映射。</br>
&emsp;&emsp;3、文件列表获取功能。文件列表获取是为了方便用户在浏览器上查看所有可下载文件。文件列表只需要遍历存储文件映射的`.list`文件即可获取压缩后的及未压缩的所有文件名，通过`HTTP`协议返回给浏览器即可。</br>
&emsp;&emsp;4、文件数据获取功能。如果要获取的是一个未压缩的高热度文件则读取所有文件信息返回给浏览器即可，如果是低热度且已经是压缩文件则需要通过原文件名和映射信息找到压缩文件并且解压缩回原文件再读取文件信息返回给浏览器进行下载。</br>
## 项目中遇到的问题
### 在客户端如何检测文件是否需要备份
&emsp;&emsp;客户端要分辨出哪些文件需要备份哪些不需要备份，这是必然要有的功能。这里我采用存储大小和最后修改时间的方式进行解决这个问题，并且为了下次启动这个程序依然可以读取到上次备份的文件信息我将文件信息写入一个文件中。
### 在服务端如何检测低热度文件并且进行压缩
&emsp;&emsp;为了完成低热度文件压缩必须能够检测出哪些是地热度文件，在这里我通过开启多线程获取文件信息对文件是否是低热度文件进行判断，并且利用`zlib`库对文件进行压缩存储，然后将原文件与压缩文件建立映射来保证可以通过原文件找到压缩文件来解决这个问题。
### 多线程的线程安全问题
&emsp;&emsp;由于用了多线程，就有可能出现同时读写临界资源的情况发生。为了解决这个问题我用读写锁来控制程序中临界资源多读少写的问题。用文件锁来防止多个一个文件同时被读写的问题。
## 项目扩展方向
&emsp;&emsp;可以进一步实现用户登录功能，不同用户拥有不同的用户空间，每个用户只能下载自己上传的文件。
&emsp;&emsp;目前文件上传大小是有限的，主要是因为内存不足无法将数据全部到内存中，但是可以采用并行和串行结合的方式对文件进行分块上传。

